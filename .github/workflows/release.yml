name: Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type (major, minor, patch)'
        required: false
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: read

jobs:
  detect-version-bump:
    name: Detect Version Bump
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      bump_type: ${{ steps.check.outputs.bump_type }}
      current_version: ${{ steps.check.outputs.current_version }}
      next_version: ${{ steps.check.outputs.next_version }}
      is_manual: ${{ github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper version detection
      
      - name: Get latest tag
        id: get_tag
        run: |
          # Get the latest tag, default to v0.0.0 if none exists
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
      
      - name: Check for Dependabot vulnerability remediations
        id: security_check
        if: github.event_name == 'push'
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          
          echo "üîç Checking for Dependabot vulnerability remediations..."
          
          # Get recent merged Dependabot PRs with their bodies
          echo "üìã Checking recent merged Dependabot PRs..."
          PR_DATA=$(gh pr list --state merged --base main --author "dependabot[bot]" --limit 10 --json number,body 2>/dev/null || echo "[]")
          
          # Check if any PR body indicates it fixes a vulnerability
          # Dependabot includes text like "> **Note:** This PR addresses a security vulnerability"
          # or links to security advisories
          VULN_PR_COUNT=$(echo "$PR_DATA" | jq -r '[.[] | select(
            (.body // "" | ascii_downcase | test("addresses.*security|security.*vulnerability|github\.com.*security-advisories|security.*advisory|fixes.*vulnerability|vulnerability.*fixed"))
          )] | length' 2>/dev/null || echo "0")
          
          if [ "$VULN_PR_COUNT" != "0" ] && [ "$VULN_PR_COUNT" != "" ] && [ "$VULN_PR_COUNT" != "null" ]; then
            echo "   ‚úÖ Found $VULN_PR_COUNT Dependabot PR(s) that remediate vulnerabilities"
            echo "$PR_DATA" | jq -r '.[] | select(
              (.body // "" | ascii_downcase | test("addresses.*security|security.*vulnerability|github\.com.*security-advisories|security.*advisory|fixes.*vulnerability|vulnerability.*fixed"))
            ) | "      PR #\(.number): Remediates vulnerability"'
            echo "true" > /tmp/vuln_fixed.txt
          else
            echo "   ‚ÑπÔ∏è No Dependabot PRs found that remediate vulnerabilities"
            echo "false" > /tmp/vuln_fixed.txt
          fi
          
          # Read result
          VULN_RESULT=$(cat /tmp/vuln_fixed.txt 2>/dev/null || echo "false")
          
          if [ "$VULN_RESULT" = "true" ]; then
            echo "üîí Dependabot vulnerability remediation detected - will trigger release"
          else
            echo "‚ÑπÔ∏è No Dependabot vulnerability remediations detected. Skipping automatic release."
            if [ "$LATEST_TAG" != "v0.0.0" ] && [ -n "$LATEST_TAG" ]; then
              COMMIT_RANGE="${LATEST_TAG}..HEAD"
            else
              COMMIT_RANGE="HEAD"
            fi
            echo "Recent commits:"
            git log --oneline ${COMMIT_RANGE} --max-count=5 2>/dev/null || git log --oneline HEAD --max-count=5
          fi
          
          echo "has_security_fixes=$VULN_RESULT" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Calculate version bump
        id: check
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          CURRENT_VERSION="${LATEST_TAG#v}"  # Remove 'v' prefix
          
          # Determine if this is a manual or automatic release
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual release - use provided bump type
            BUMP_TYPE="${{ github.event.inputs.bump_type }}"
            SHOULD_RELEASE=true
          else
            # Automatic release - check for security fixes
            HAS_SECURITY="${{ steps.security_check.outputs.has_security_fixes }}"
            if [ "$HAS_SECURITY" = "true" ]; then
              # Automatic release for security fixes - always patch bump
              BUMP_TYPE="patch"
              SHOULD_RELEASE=true
              echo "üöÄ Auto-releasing patch version for security fixes"
            else
              # No security fixes, skip release
              BUMP_TYPE="patch"
              SHOULD_RELEASE=false
              echo "‚è≠Ô∏è Skipping release - no security fixes detected"
            fi
          fi
          
          echo "Current version: $CURRENT_VERSION"
          echo "Bump type: $BUMP_TYPE"
          echo "Should release: $SHOULD_RELEASE"
          
          # Parse current version
          IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR="${VERSION_PARTS[0]:-0}"
          MINOR="${VERSION_PARTS[1]:-0}"
          PATCH="${VERSION_PARTS[2]:-0}"
          
          # Bump version based on type
          case "$BUMP_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          
          if [ "$SHOULD_RELEASE" = "true" ]; then
            echo "Will release: v$NEXT_VERSION"
          fi

  release:
    name: Build and Release
    needs: detect-version-bump
    if: needs.detect-version-bump.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
          cache: true
      
      - name: Install GoReleaser
        run: |
          curl -sL https://github.com/goreleaser/goreleaser/releases/download/v1.24.0/goreleaser_Linux_x86_64.tar.gz | tar xz
          sudo mv goreleaser /usr/local/bin/
          goreleaser --version
      
      - name: Generate Changelog
        id: changelog
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          NEXT_VERSION="v${{ needs.detect-version-bump.outputs.next_version }}"
          
          echo "Generating changelog from $LATEST_TAG to HEAD"
          
          if [ -z "$LATEST_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" ${LATEST_TAG}..HEAD)
          fi
          
          # Group commits by type
          FEATURES=$(echo "$CHANGELOG" | grep -E "^- feat" || true)
          FIXES=$(echo "$CHANGELOG" | grep -E "^- (fix|security)" || true)
          CHORES=$(echo "$CHANGELOG" | grep -E "^- (chore|deps|build|ci)" || true)
          DOCS=$(echo "$CHANGELOG" | grep -E "^- docs" || true)
          OTHERS=$(echo "$CHANGELOG" | grep -vE "^- (feat|fix|security|chore|deps|build|ci|docs)" || true)
          
          # Build changelog
          CHANGELOG_TEXT="## What's Changed in $NEXT_VERSION"$'\n\n'
          
          if [ -n "$FEATURES" ]; then
            CHANGELOG_TEXT+="### ‚ú® New Features"$'\n'
            CHANGELOG_TEXT+="$FEATURES"$'\n\n'
          fi
          
          if [ -n "$FIXES" ]; then
            CHANGELOG_TEXT+="### üêõ Bug Fixes & Security"$'\n'
            CHANGELOG_TEXT+="$FIXES"$'\n\n'
          fi
          
          if [ -n "$CHORES" ]; then
            CHANGELOG_TEXT+="### üîß Maintenance"$'\n'
            CHANGELOG_TEXT+="$CHORES"$'\n\n'
          fi
          
          if [ -n "$DOCS" ]; then
            CHANGELOG_TEXT+="### üìö Documentation"$'\n'
            CHANGELOG_TEXT+="$DOCS"$'\n\n'
          fi
          
          if [ -n "$OTHERS" ]; then
            CHANGELOG_TEXT+="### üîÄ Other Changes"$'\n'
            CHANGELOG_TEXT+="$OTHERS"$'\n\n'
          fi
          
          CHANGELOG_TEXT+="**Full Changelog**: https://github.com/eapolsniper/endpointbom/compare/${LATEST_TAG}...${NEXT_VERSION}"
          
          # Save to file
          echo "$CHANGELOG_TEXT" > /tmp/changelog.md
          
          echo "Generated changelog:"
          cat /tmp/changelog.md
      
      - name: Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          VERSION="v${{ needs.detect-version-bump.outputs.next_version }}"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"
      
      - name: Debug - Check git status before GoReleaser
        run: |
          echo "=== Git Status ==="
          git status
          echo "=== Modified files ==="
          git diff --name-only || true
          echo "=== Untracked files ==="
          git ls-files --others --exclude-standard || true
      
      - name: Clean auto-generated files
        run: |
          # Only remove specific auto-generated files/directories
          rm -f LICENSE.md
          rm -rf completions/
          rm -rf manpages/
          # Reset README.md if it was modified
          git checkout -- README.md 2>/dev/null || true
          echo "=== Git Status After Clean ==="
          git status
      
      - name: Verify source structure
        run: |
          echo "=== Current directory ==="
          pwd
          echo "=== Directory contents ==="
          ls -la
          echo "=== cmd directory ==="
          ls -la cmd/ || echo "cmd directory not found!"
          echo "=== cmd/endpointbom ==="
          ls -la cmd/endpointbom/ || echo "cmd/endpointbom not found!"
      
      - name: Run GoReleaser
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          goreleaser release --clean --release-notes /tmp/changelog.md

  update-changelog:
    name: Update CHANGELOG.md
    needs: [detect-version-bump, release]
    if: needs.detect-version-bump.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
      
      - name: Update CHANGELOG.md
        run: |
          VERSION="v${{ needs.detect-version-bump.outputs.next_version }}"
          DATE=$(date +%Y-%m-%d)
          
          # Create new changelog entry
          NEW_ENTRY="## [${{ needs.detect-version-bump.outputs.next_version }}] - $DATE"$'\n\n'
          NEW_ENTRY+="See the [GitHub Release](https://github.com/eapolsniper/endpointbom/releases/tag/$VERSION) for full details."$'\n\n'
          NEW_ENTRY+="---"$'\n\n'
          
          # Insert after the first line (title)
          if [ -f CHANGELOG.md ]; then
            # Read first line
            FIRST_LINE=$(head -n 1 CHANGELOG.md)
            # Read rest of file
            REST=$(tail -n +2 CHANGELOG.md)
            # Combine
            echo "$FIRST_LINE" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "$NEW_ENTRY" >> CHANGELOG.md
            echo "$REST" >> CHANGELOG.md
          else
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "$NEW_ENTRY" >> CHANGELOG.md
          fi
          
          # Update current version at bottom
          if grep -q "^**Current Version**:" CHANGELOG.md; then
            sed -i "s/^**Current Version**:.*/**Current Version**: ${{ needs.detect-version-bump.outputs.next_version }}/" CHANGELOG.md
          fi
      
      - name: Commit and push CHANGELOG.md
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add CHANGELOG.md
          git commit -m "chore: update CHANGELOG.md for v${{ needs.detect-version-bump.outputs.next_version }}" || exit 0
          git push origin main

